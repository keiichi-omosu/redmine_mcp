# システムの仕組み

## このシステムは何をするのか

Redmine MCPサーバーは、AI（人工知能）とRedmine（プロジェクト管理ツール）を繋ぐ「橋渡し役」なのだ。

想像してほしいのだ。あなたがAIアシスタントに「プロジェクトのチケット情報を調べて」とお願いしたとき、AIは直接Redmineにアクセスできないのだ。そこで、このシステムが仲介役となって、AIの要求をRedmineに伝え、結果をAIに返すのだ。

### 具体的な例

```
あなた: 「AI君、チケット#123の内容を教えて」
    ↓
AI: 「チケット情報が必要だな...MCPサーバーに聞いてみよう」
    ↓
MCPサーバー: 「了解！Redmineからチケット#123を取得します」
    ↓
Redmine: 「はい、チケット#123の情報です」
    ↓
MCPサーバー: 「AIさん、チケット情報をお届けします」
    ↓
AI: 「チケット#123は『ログイン機能の修正』で、優先度は高で...」
```

## 全体の流れ

システム全体の流れを、家の建築に例えて説明するのだ。

```
【お客様】           【建築士】         【工務店】         【資材倉庫】
   AI   ────要求───→ MCPサーバー ────注文───→ Redmine
   ↑                    ↓               ↓            ↓
   └────回答────────────┘        ←──資材──────┘
```

1. **お客様（AI）**: 「こんな情報が欲しい」と要求
2. **建築士（MCPサーバー）**: 要求を理解し、適切な形に整理
3. **工務店（APIクライアント）**: 実際にRedmineとやり取り
4. **資材倉庫（Redmine）**: 実際のデータを保管している場所

## 主要な部品とその役割

システムは大きく分けて4つの部品で構成されているのだ。

### 1. 入り口（サーバー）

AIがシステムにアクセスするための入り口なのだ。2つの種類があるのだ：

**HTTPサーバー（server.rb）**
- Webブラウザのような方法でアクセス
- 開発やテスト時に使いやすい
- 「http://localhost:3000」のようなURLでアクセス

**STDIOサーバー（stdio_server.rb）**
- 直接プログラム同士で会話
- VS CodeやClaude等のAIツールで使用
- より効率的で軽量

### 2. 司令塔（RedmineMcpHandler）

システムの脳みその部分なのだ。AIからの要求を理解し、適切な処理を決定するのだ。

**主な仕事**
- AIの要求を解析：「チケット情報が欲しいのね」
- 適切な処理を選択：「じゃあRedmineから取得しよう」
- 結果を整理：「この形でAIに返そう」

**対応できる操作**
- `get_redmine_ticket`：チケット情報の取得
- `create_redmine_ticket`：新しいチケットの作成

### 3. 実行部隊（RedmineApiClient）

実際にRedmineとやり取りする専門部隊なのだ。

**主な仕事**
- Redmineとの通信：「チケット#123をください」
- データの整理：受け取った情報を使いやすい形に変換
- エラー処理：「通信に失敗しました」等の問題対応

### 4. サポート部隊（各種ヘルパー）

システムを支える縁の下の力持ちなのだ。

**JSON-RPCヘルパー**
- AIとの会話方法（プロトコル）を管理
- 「正しいフォーマットで話せているかな？」をチェック

**ログシステム**
- 何が起こったかの記録を残す
- 問題が起きたときの調査に役立つ

**設定管理**
- システムの基本情報を管理
- バージョン情報や各種設定を一元管理

## データの流れ

チケット情報を取得する場合の、データの流れを追ってみるのだ。

```
1. 【AIの要求】
   「チケット#123の情報が欲しい」
   
   ↓ JSON-RPC形式で送信
   
2. 【サーバーで受信】
   HTTPまたはSTDIOサーバーが要求を受け取り
   
   ↓ 内部処理へ転送
   
3. 【司令塔で判断】
   RedmineMcpHandler が要求内容を解析
   「これはチケット取得の要求だな」
   
   ↓ API クライアントに指示
   
4. 【実行部隊が作業】
   RedmineApiClient が Redmine にアクセス
   「GET /issues/123.json」
   
   ↓ Redmine からレスポンス
   
5. 【データ整理】
   受け取った JSON データを AI 用に整理
   
   ↓ レスポンス作成
   
6. 【AIに回答】
   「チケット#123は『ログイン機能修正』です」
```

### エラーが起きたときの流れ

```
何か問題が発生 → エラー内容を記録 → 分かりやすいメッセージに変換 → AIに通知
```

例：
- Redmineが応答しない → 「通信エラーが発生しました」
- チケットが見つからない → 「指定されたチケットは存在しません」
- APIキーが間違い → 「認証に失敗しました」

## セキュリティについて

システムの安全性について、分かりやすく説明するのだ。

### 1. 鍵の管理（APIキー）

Redmineにアクセスするための「鍵」（APIキー）は、とても重要なのだ。

**安全な保管方法**
- 環境変数に保存（プログラムの外側に置く）
- コードファイルには絶対に書かない
- ログファイルにも記録しない

**悪い例**
```ruby
# これはダメ！
api_key = "abc123def456"  # コードに直接書いてはいけない
```

**良い例**
```ruby
# これが正解！
api_key = ENV['REDMINE_API_KEY']  # 環境変数から取得
```

### 2. 通信の保護

AIとシステム、システムとRedmineの間の通信を保護するのだ。

- **暗号化通信**：HTTPSを使用してデータを暗号化
- **アクセス制限**：認証された相手のみアクセス可能
- **データの最小化**：必要最小限の情報のみ送受信

### 3. 情報の管理

- **一時的な保存**：チケット情報はメモリ上でのみ処理
- **ログの安全性**：機密情報はログに残さない
- **権限の制限**：Redmineで許可された情報のみアクセス

## 拡張について

このシステムは将来的に機能を追加しやすいように設計されているのだ。

### 新しい機能を追加するときの流れ

1. **司令塔に新しい命令を教える**
   - 「今度はコメント投稿もできるようにしよう」
   
2. **実行部隊に新しい技を覚えさせる**
   - Redmine APIの新しい使い方を実装
   
3. **テストで動作確認**
   - 「ちゃんと動くかな？」を確認
   
4. **AIに新しい機能をお知らせ**
   - 「こんな新機能が使えるようになりました」

### 現在計画されている拡張

- **コメント機能**：チケットにコメントを追加
- **検索機能**：条件を指定してチケットを検索
- **ファイル添付**：チケットにファイルを添付
- **プロジェクト管理**：プロジェクト情報の取得・更新

## まとめ

Redmine MCPサーバーは、AIとRedmineの間で情報をやり取りするための「翻訳者」のような存在なのだ。

**システムの特徴**
- **シンプル**：必要最小限の機能に絞り込み
- **安全**：セキュリティを最優先に設計
- **拡張可能**：将来的な機能追加が容易
- **信頼性**：エラー処理とテストを充実

**なぜこのような構成なのか**
- AIとRedmineは直接話せないから、通訳が必要
- セキュリティを保つため、専用の安全な経路を用意
- 将来の機能追加に備えて、部品を分けて整理
- 問題が起きたときに原因を特定しやすい構造

このシステムを使うことで、AIがRedmineの情報を安全に、効率的に活用できるようになるのだ！